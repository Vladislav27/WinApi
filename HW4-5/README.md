Задание 4:

1.  Создайте пустой C++ проект.
2.  Реализуйте пустую фукнцию WinMain.
3.  Зарегистрируйте класс overlapped-окна и напишите оконную процедуру, обрабатывающую сообщение WM_DESTROY.
4.  Создайте одно такое окно, отобразите его и запустите цикл обработки сообщений. CreateWindowEx, ShowWindow, GetMessage, TranslateMessage, DispatchMessage.
5.  Создайте класс окна с функциями регистрации класса, создания окна и со статической оконной функцией. Запоминайте HWND окна при создании и указатель на окно в SetWindowLong.
6. Нарисуйте в окне эллипс с фоном.
Обработайте сообщение:
WM_PAINT
7. Заставьте эллипс перемещаться по экрану по таймеру. Под перемещением по экрану подразумевается, движение с отталкиванием от стенок. Важно: эллипс при движении не должен выходить за границы окна. Для этого размер можно зафиксировать (SetWindowPos). Однако, рекомендуется писать код так, чтобы быть готовым обрабатывать сообщение WM_SIZE в следующем задании.
Обработайте сообщение:
WM_TIMER
8. Обеспечьте плавную отрисовку при помощи контекста в памяти (двойная буферизация).

Задание 5:

1. Реализуйте предыдущее задание.
Переделайте предыдущий класс так, чтобы метод Create порождал дочернее окно, принимая на вход HWND родительского окна.

2. Сделайте новый класс. Он потребуется для создания родительского окна верхнего уровня.

3. Добавьте в него плитку из NxM дочерних окон так, чтобы каждое из окон занимало свою конкретную позицию. Размер “плитки” может быть задан константами в коде, однако все остальные параметры должны вычисляться исходя из размеров окна.

4. При изменении размеров родительского окна дочерние окна по прежнему должны занимать каждый свою позицию.

5. Все окна изначально считаются неактивными, значит там просто нарисован шарик, который не двигается. При клике на одно из дочерних окон соответствующий шарик должен активироваться и начинать двигаться, при этом менять свой цвет. При клике на соседнее дочернее окно, шарик должен остановиться, а в активном окне нужно провернуть все те же операции.
